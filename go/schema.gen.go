// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package opencli

import "encoding/json"
import "fmt"
import "regexp"

type Argument struct {
	// A list of accepted values
	AcceptedValues []string `json:"acceptedValues,omitempty" yaml:"acceptedValues,omitempty" mapstructure:"acceptedValues,omitempty"`

	// The argument arity. Arity defines the minimum and maximum number of argument
	// values
	Arity *Arity `json:"arity,omitempty" yaml:"arity,omitempty" mapstructure:"arity,omitempty"`

	// The argument description
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The argument group
	Group *string `json:"group,omitempty" yaml:"group,omitempty" mapstructure:"group,omitempty"`

	// Whether or not the argument is hidden
	Hidden bool `json:"hidden,omitempty" yaml:"hidden,omitempty" mapstructure:"hidden,omitempty"`

	// Custom metadata
	Metadata []Metadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// The argument name
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Whether or not the argument is required
	Required bool `json:"required,omitempty" yaml:"required,omitempty" mapstructure:"required,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Argument) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Argument: required")
	}
	type Plain Argument
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["hidden"]; !ok || v == nil {
		plain.Hidden = false
	}
	if v, ok := raw["required"]; !ok || v == nil {
		plain.Required = false
	}
	*j = Argument(plain)
	return nil
}

// Arity defines the minimum and maximum number of argument values
type Arity struct {
	// The maximum number of values allowed
	Maximum int `json:"maximum,omitempty" yaml:"maximum,omitempty" mapstructure:"maximum,omitempty"`

	// The minimum number of values allowed
	Minimum int `json:"minimum,omitempty" yaml:"minimum,omitempty" mapstructure:"minimum,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Arity) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain Arity
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["maximum"]; !ok || v == nil {
		plain.Maximum = 1.0
	}
	if 0 > plain.Maximum {
		return fmt.Errorf("field %s: must be >= %v", "maximum", 0)
	}
	if v, ok := raw["minimum"]; !ok || v == nil {
		plain.Minimum = 1.0
	}
	if 0 > plain.Minimum {
		return fmt.Errorf("field %s: must be >= %v", "minimum", 0)
	}
	*j = Arity(plain)
	return nil
}

type CliInfo struct {
	// The contact information
	Contact *Contact `json:"contact,omitempty" yaml:"contact,omitempty" mapstructure:"contact,omitempty"`

	// A description of the application
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The application license
	License *License `json:"license,omitempty" yaml:"license,omitempty" mapstructure:"license,omitempty"`

	// A short summary of the application
	Summary *string `json:"summary,omitempty" yaml:"summary,omitempty" mapstructure:"summary,omitempty"`

	// The application title
	Title string `json:"title" yaml:"title" mapstructure:"title"`

	// The application version
	Version string `json:"version" yaml:"version" mapstructure:"version"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CliInfo) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["title"]; raw != nil && !ok {
		return fmt.Errorf("field title in CliInfo: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in CliInfo: required")
	}
	type Plain CliInfo
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CliInfo(plain)
	return nil
}

type Command struct {
	// The command aliases
	Aliases []string `json:"aliases,omitempty" yaml:"aliases,omitempty" mapstructure:"aliases,omitempty"`

	// The command arguments
	Arguments []Argument `json:"arguments,omitempty" yaml:"arguments,omitempty" mapstructure:"arguments,omitempty"`

	// The command's sub commands
	Commands []Command `json:"commands,omitempty" yaml:"commands,omitempty" mapstructure:"commands,omitempty"`

	// The command description
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Examples of how to use the command
	Examples []string `json:"examples,omitempty" yaml:"examples,omitempty" mapstructure:"examples,omitempty"`

	// The command's exit codes
	ExitCodes []ExitCode `json:"exitCodes,omitempty" yaml:"exitCodes,omitempty" mapstructure:"exitCodes,omitempty"`

	// Whether or not the command is hidden
	Hidden bool `json:"hidden,omitempty" yaml:"hidden,omitempty" mapstructure:"hidden,omitempty"`

	// Indicate whether or not the command requires interactive input
	Interactive bool `json:"interactive,omitempty" yaml:"interactive,omitempty" mapstructure:"interactive,omitempty"`

	// Custom metadata
	Metadata []Metadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// The command name
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The command options
	Options []Option `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Command) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Command: required")
	}
	type Plain Command
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["hidden"]; !ok || v == nil {
		plain.Hidden = false
	}
	if v, ok := raw["interactive"]; !ok || v == nil {
		plain.Interactive = false
	}
	*j = Command(plain)
	return nil
}

// Contact information
type Contact struct {
	// The email address of the contact person/organization. This MUST be in the form
	// of an email address.
	Email *Email `json:"email,omitempty" yaml:"email,omitempty" mapstructure:"email,omitempty"`

	// The identifying name of the contact person/organization
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The URI for the contact information. This MUST be in the form of a URI.
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`
}

type Conventions struct {
	// Whether or not grouping of short options are allowed
	GroupOptions bool `json:"groupOptions,omitempty" yaml:"groupOptions,omitempty" mapstructure:"groupOptions,omitempty"`

	// The option argument separator
	OptionSeparator string `json:"optionSeparator,omitempty" yaml:"optionSeparator,omitempty" mapstructure:"optionSeparator,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Conventions) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain Conventions
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["groupOptions"]; !ok || v == nil {
		plain.GroupOptions = true
	}
	if v, ok := raw["optionSeparator"]; !ok || v == nil {
		plain.OptionSeparator = " "
	}
	*j = Conventions(plain)
	return nil
}

type Email string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Email) UnmarshalJSON(value []byte) error {
	type Plain Email
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`.+\@.+\..+`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `.+\@.+\..+`)
	}
	*j = Email(plain)
	return nil
}

type ExitCode struct {
	// The exit code
	Code int `json:"code" yaml:"code" mapstructure:"code"`

	// The exit code description
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExitCode) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in ExitCode: required")
	}
	type Plain ExitCode
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ExitCode(plain)
	return nil
}

type License struct {
	// The SPDX license identifier
	Identifier *string `json:"identifier,omitempty" yaml:"identifier,omitempty" mapstructure:"identifier,omitempty"`

	// The license name
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The URI for the license. This MUST be in the form of a URI
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`
}

type Metadata struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Value corresponds to the JSON schema field "value".
	Value interface{} `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Metadata) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Metadata: required")
	}
	type Plain Metadata
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Metadata(plain)
	return nil
}

// The OpenCLI description
type OpenCLIJson struct {
	// Root command arguments
	Arguments []Argument `json:"arguments,omitempty" yaml:"arguments,omitempty" mapstructure:"arguments,omitempty"`

	// Root command sub commands
	Commands []Command `json:"commands,omitempty" yaml:"commands,omitempty" mapstructure:"commands,omitempty"`

	// The conventions used by the CLI
	Conventions *Conventions `json:"conventions,omitempty" yaml:"conventions,omitempty" mapstructure:"conventions,omitempty"`

	// Examples of how to use the CLI
	Examples []string `json:"examples,omitempty" yaml:"examples,omitempty" mapstructure:"examples,omitempty"`

	// Root command exit codes
	ExitCodes []ExitCode `json:"exitCodes,omitempty" yaml:"exitCodes,omitempty" mapstructure:"exitCodes,omitempty"`

	// Information about the CLI
	Info CliInfo `json:"info" yaml:"info" mapstructure:"info"`

	// Indicates whether or not the command requires interactive input
	Interactive bool `json:"interactive,omitempty" yaml:"interactive,omitempty" mapstructure:"interactive,omitempty"`

	// Custom metadata
	Metadata []Metadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// The OpenCLI version number
	Opencli string `json:"opencli" yaml:"opencli" mapstructure:"opencli"`

	// Root command options
	Options []Option `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OpenCLIJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["info"]; raw != nil && !ok {
		return fmt.Errorf("field info in OpenCLIJson: required")
	}
	if _, ok := raw["opencli"]; raw != nil && !ok {
		return fmt.Errorf("field opencli in OpenCLIJson: required")
	}
	type Plain OpenCLIJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["interactive"]; !ok || v == nil {
		plain.Interactive = false
	}
	*j = OpenCLIJson(plain)
	return nil
}

type Option struct {
	// The option's aliases
	Aliases []string `json:"aliases,omitempty" yaml:"aliases,omitempty" mapstructure:"aliases,omitempty"`

	// The option's arguments
	Arguments []Argument `json:"arguments,omitempty" yaml:"arguments,omitempty" mapstructure:"arguments,omitempty"`

	// The option description
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The option group
	Group *string `json:"group,omitempty" yaml:"group,omitempty" mapstructure:"group,omitempty"`

	// Whether or not the option is hidden
	Hidden bool `json:"hidden,omitempty" yaml:"hidden,omitempty" mapstructure:"hidden,omitempty"`

	// Custom metadata
	Metadata []Metadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// The option name
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Specifies whether the option is accessible from the immediate parent command
	// and, recursively, from its subcommands
	Recursive bool `json:"recursive,omitempty" yaml:"recursive,omitempty" mapstructure:"recursive,omitempty"`

	// Whether or not the option is required
	Required bool `json:"required,omitempty" yaml:"required,omitempty" mapstructure:"required,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Option) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Option: required")
	}
	type Plain Option
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["hidden"]; !ok || v == nil {
		plain.Hidden = false
	}
	if v, ok := raw["recursive"]; !ok || v == nil {
		plain.Recursive = false
	}
	if v, ok := raw["required"]; !ok || v == nil {
		plain.Required = false
	}
	*j = Option(plain)
	return nil
}
